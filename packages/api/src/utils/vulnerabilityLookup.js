import { VULNERABILITY_APIS, API_ERROR_MESSAGES, ID_PATTERNS } from '../config/vulnerability-apis.js';

class RateLimiter {
  constructor(limit, window) {
    this.limit = limit;
    this.window = window;
    this.tokens = [];
  }

  async waitForToken() {
    const now = Date.now();
    this.tokens = this.tokens.filter(token => now - token < this.window);
    
    if (this.tokens.length >= this.limit) {
      const oldestToken = this.tokens[0];
      const waitTime = this.window - (now - oldestToken);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
    
    this.tokens.push(now);
  }
}

// Rate limiter instance for NVD API
const nvdRateLimiter = new RateLimiter(
  VULNERABILITY_APIS.NVD.rateLimit.requests,
  VULNERABILITY_APIS.NVD.rateLimit.window
);

/**
 * Standardize vulnerability data format across different sources
 */
function standardizeVulnerabilityData(data, source) {
  switch (source) {
    case 'NVD':
      const cveData = data.vulnerabilities?.[0]?.cve;
      if (!cveData) {
        return null;
      }
      const cvssV31 = cveData.metrics?.cvssMetricV31?.[0];
      return {
        vulnerabilityId: cveData.id,
        type: 'CVE',
        title: `Vulnerability in ${cveData.id}`,
        description: cveData.descriptions?.find(d => d.lang === 'en')?.value || 'No description available.',
        severity: cvssV31?.cvssData?.baseSeverity || 'UNKNOWN',
        cvssScore: cvssV31?.cvssData?.baseScore || null,
        remediation: 'Refer to the official advisory and vendor patches.',
        references: {
          urls: cveData.references?.map(ref => ref.url) || []
        },
        source: 'NVD'
      };
    // MITRE case would need a proper parser for HTML or a different API endpoint.
    // This is a placeholder for future implementation.
    case 'MITRE':
      return {
        vulnerabilityId: data.id,
        type: 'CVE',
        title: data.title || 'No title available',
        description: data.description || 'No description available',
        severity: data.severity || 'UNKNOWN',
        cvssScore: null,
        remediation: null,
        references: {
          urls: data.references || []
        },
        source: 'MITRE'
      };

    default:
      throw new Error('Unknown vulnerability data source');
  }
}

/**
 * Calculate severity level based on CVSS score
 */
function calculateSeverity(cvssScore) {
  if (!cvssScore) return 'UNKNOWN';
  if (cvssScore >= 9.0) return 'CRITICAL';
  if (cvssScore >= 7.0) return 'HIGH';
  if (cvssScore >= 4.0) return 'MEDIUM';
  return 'LOW';
}

/**
 * Validate CVE or GHSA ID format
 */
export function validateVulnerabilityId(id) {
  return ID_PATTERNS.CVE.test(id) || ID_PATTERNS.GHSA.test(id);
}

/**
 * Fetch vulnerability data from NVD
 */
async function fetchFromNVD(cveId) {
  await nvdRateLimiter.waitForToken();

  const response = await fetch(
    `${VULNERABILITY_APIS.NVD.baseUrl}?cveId=${cveId}`
  );

  if (!response.ok) {
    if (response.status === 429) {
      throw new Error(API_ERROR_MESSAGES.RATE_LIMIT_EXCEEDED);
    }
    if (response.status === 404) {
      return null; // Not found is not an error, just no result.
    }
    throw new Error(API_ERROR_MESSAGES.EXTERNAL_API_ERROR);
  }

  const data = await response.json();
  if (!data.vulnerabilities || data.vulnerabilities.length === 0) {
    return null;
  }

  return standardizeVulnerabilityData({ vulnerabilities: data.vulnerabilities }, 'NVD');
}

/**
 * Fetch vulnerability data from MITRE (fallback)
 */
async function fetchFromMITRE(cveId) {
  // This is a placeholder. A real implementation would need to parse HTML
  // or use a different, more structured data source if available from MITRE.
  console.warn(`[Vulnerability Lookup] MITRE lookup for ${cveId} is not fully implemented and using placeholder data.`);
  return Promise.resolve(null); // Returning null as it's not implemented.
}

/**
 * Looks up a vulnerability by its ID from external sources with a fallback mechanism.
 * @param {string} id The vulnerability identifier (e.g., CVE-2023-1234).
 * @returns {Promise<object|null>} A standardized vulnerability object or null if not found.
 */
export async function lookupExternalVulnerability(id) {
  if (!validateVulnerabilityId(id)) {
    throw new Error(API_ERROR_MESSAGES.INVALID_CVE_FORMAT);
  }

  try {
    const nvdResult = await fetchFromNVD(id);
    if (nvdResult) {
      return nvdResult;
    }
    
    // Fallback to MITRE if not found in NVD
    const mitreResult = await fetchFromMITRE(id);
    if (mitreResult) {
        return mitreResult;
    }

    return null; // Return null if not found in any source
  } catch (error) {
    console.error(`[Vulnerability Lookup] Failed to lookup ${id}:`, error.message);
    // In case of API errors, we might still try the fallback.
    if (error.message !== API_ERROR_MESSAGES.RATE_LIMIT_EXCEEDED) {
        try {
            const mitreResult = await fetchFromMITRE(id);
            if (mitreResult) return mitreResult;
        } catch (mitreError) {
            console.error(`[Vulnerability Lookup] Fallback to MITRE for ${id} also failed:`, mitreError.message);
        }
    }
    throw error; // Re-throw the original error if all fallbacks fail
  }
}

/**
 * Search for vulnerabilities by keyword (for future implementation)
 */
export async function searchVulnerabilities(query) {
  await nvdRateLimiter.waitForToken();

  const response = await fetch(
    `${VULNERABILITY_APIS.NVD.baseUrl}?keywordSearch=${encodeURIComponent(query)}`,
    {
      headers: {
        'Accept': 'application/json'
      },
      timeout: VULNERABILITY_APIS.NVD.timeout
    }
  );

  if (!response.ok) {
    if (response.status === 429) {
      throw new Error(API_ERROR_MESSAGES.RATE_LIMIT_EXCEEDED);
    }
    throw new Error(API_ERROR_MESSAGES.EXTERNAL_API_ERROR);
  }

  const data = await response.json();
  return data.vulnerabilities?.map(vuln => standardizeVulnerabilityData({ vulnerabilities: [vuln] }, 'NVD')).filter(Boolean) || [];
}