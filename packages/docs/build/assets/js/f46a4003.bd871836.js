"use strict";(self.webpackChunk_stagehand_docs=self.webpackChunk_stagehand_docs||[]).push([[669],{1184:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var t=s(6540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}},3732:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"frontend-architecture","title":"Frontend Architecture & Conventions","description":"This document provides a detailed guide to the structure, conventions, and patterns used in the packages/web service. It is intended for developers working on the frontend to ensure consistency and maintainability.","source":"@site/docs/frontend-architecture.md","sourceDirName":".","slug":"/frontend-architecture","permalink":"/frontend-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/stagehand/tree/main/packages/docs/docs/frontend-architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Backend Architecture & Conventions","permalink":"/backend-architecture"},"next":{"title":"API Reference: Authentication","permalink":"/api/auth"}}');var i=s(4848),o=s(1184);const r={},c="Frontend Architecture & Conventions",a={},l=[{value:"Technology Stack",id:"technology-stack",level:2},{value:"Directory Structure",id:"directory-structure",level:2},{value:"Key Concepts &amp; Conventions",id:"key-concepts--conventions",level:2},{value:"1. Component Strategy",id:"1-component-strategy",level:3},{value:"2. State Management",id:"2-state-management",level:3},{value:"3. Data Fetching &amp; API Communication",id:"3-data-fetching--api-communication",level:3},{value:"4. Routing",id:"4-routing",level:3},{value:"5. Styling",id:"5-styling",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"frontend-architecture--conventions",children:"Frontend Architecture & Conventions"})}),"\n",(0,i.jsxs)(n.p,{children:["This document provides a detailed guide to the structure, conventions, and patterns used in the ",(0,i.jsx)(n.code,{children:"packages/web"})," service. It is intended for developers working on the frontend to ensure consistency and maintainability."]}),"\n",(0,i.jsx)(n.h2,{id:"technology-stack",children:"Technology Stack"}),"\n",(0,i.jsx)(n.p,{children:"The frontend is a modern Single-Page Application (SPA) built with the following core technologies:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Build Tool:"})," ",(0,i.jsx)(n.a,{href:"https://vitejs.dev/",children:"Vite"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Framework:"})," ",(0,i.jsx)(n.a,{href:"https://react.dev/",children:"React"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Routing:"})," ",(0,i.jsx)(n.a,{href:"https://reactrouter.com/",children:"React Router"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Management:"})," ",(0,i.jsx)(n.a,{href:"https://github.com/pmndrs/zustand",children:"Zustand"})," for global state."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Styling:"})," ",(0,i.jsx)(n.a,{href:"https://tailwindcss.com/",children:"Tailwind CSS v4"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"UI Components:"})," ",(0,i.jsx)(n.a,{href:"https://headlessui.com/",children:"Headless UI"})," for accessible, unstyled components."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Icons:"})," ",(0,i.jsx)(n.a,{href:"https://lucide.dev/guide/packages/lucide-react",children:"Lucide React"})," and ",(0,i.jsx)(n.a,{href:"https://heroicons.com/",children:"Heroicons"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"directory-structure",children:"Directory Structure"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"packages/web/src/"})," directory is organized as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"packages/web/src/\n\u251c\u2500\u2500 main.jsx          # Application entry point, renders App.\n\u251c\u2500\u2500 App.jsx           # Root component, sets up routing.\n\u251c\u2500\u2500 index.css         # Global styles and Tailwind CSS imports.\n\u251c\u2500\u2500 components/       # Reusable UI components, organized by feature.\n\u251c\u2500\u2500 pages/            # Top-level components corresponding to specific routes.\n\u251c\u2500\u2500 stores/           # Zustand store definitions for global state.\n\u251c\u2500\u2500 hooks/            # Custom React hooks (e.g., useDebounce).\n\u2514\u2500\u2500 lib/              # Utility functions, constants, and external library configs.\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"key-concepts--conventions",children:"Key Concepts & Conventions"}),"\n",(0,i.jsx)(n.h3,{id:"1-component-strategy",children:"1. Component Strategy"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pages:"})," Components in ",(0,i.jsx)(n.code,{children:"src/pages/"})," are top-level views that are directly mapped to a route in ",(0,i.jsx)(n.code,{children:"App.jsx"}),". They are responsible for fetching page-specific data and composing the layout using smaller components."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Shared Components:"})," Components in ",(0,i.jsx)(n.code,{children:"src/components/"}),' are designed to be reusable across different pages. They should be "dumb" whenever possible, meaning they receive data and callbacks via props and do not have their own complex state.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feature-Based Organization:"})," Inside ",(0,i.jsx)(n.code,{children:"src/components/"}),", create subdirectories for specific features (e.g., ",(0,i.jsx)(n.code,{children:"components/findings"}),", ",(0,i.jsx)(n.code,{children:"components/settings"}),") to keep related components grouped together."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-state-management",children:"2. State Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Local State:"})," For state that is only used within a single component or a small, co-located group of components, use React's built-in ",(0,i.jsx)(n.code,{children:"useState"})," and ",(0,i.jsx)(n.code,{children:"useReducer"})," hooks."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Global State (Zustand):"})," For state that needs to be shared across the entire application (e.g., user authentication status, company/organization data), use Zustand.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stores:"})," All Zustand stores are defined in ",(0,i.jsx)(n.code,{children:"src/stores/"}),". Create a new file for each logical slice of state (e.g., ",(0,i.jsx)(n.code,{children:"useAuthStore.js"}),", ",(0,i.jsx)(n.code,{children:"useProjectStore.js"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Immutability:"}),' Zustand stores use Immer internally, so you can write "mutating" logic inside your actions, and Immer will handle the immutable updates safely.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Selectors:"})," To prevent unnecessary re-renders, always use selectors when accessing a store, especially for objects.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Good:"})," ",(0,i.jsx)(n.code,{children:"const user = useAuthStore(state => state.user);"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bad:"})," ",(0,i.jsx)(n.code,{children:"const { user } = useAuthStore();"})," (This will cause re-renders when any part of the auth store changes)."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-data-fetching--api-communication",children:"3. Data Fetching & API Communication"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Data fetching should be performed within Zustand store actions or in page components for one-off requests."}),"\n",(0,i.jsxs)(n.li,{children:["The API client (e.g., using ",(0,i.jsx)(n.code,{children:"fetch"}),") should be centralized, ideally in a utility file within ",(0,i.jsx)(n.code,{children:"src/lib/"}),", to handle common logic like setting headers, error handling, and base URL configuration."]}),"\n",(0,i.jsx)(n.li,{children:"Use Zustand actions to manage the lifecycle of data: fetching, success, and error states. This keeps the data-fetching logic separate from the UI and makes it easy to share and cache data across components."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-routing",children:"4. Routing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Routing is managed by ",(0,i.jsx)(n.code,{children:"react-router-dom"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["All application routes are defined in ",(0,i.jsx)(n.code,{children:"src/App.jsx"})," using the ",(0,i.jsx)(n.code,{children:"<Routes>"})," and ",(0,i.jsx)(n.code,{children:"<Route>"})," components."]}),"\n",(0,i.jsxs)(n.li,{children:["Protected routes that require authentication should be wrapped in a layout or component that checks the user's auth status from the ",(0,i.jsx)(n.code,{children:"useAuthStore"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"5-styling",children:"5. Styling"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tailwind CSS First:"})," All styling should be done using Tailwind CSS utility classes directly in the JSX. Avoid writing custom CSS files whenever possible."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Component Logic:"})," Use conditional classes in React for dynamic styling based on component state or props."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Headless UI:"})," Leverage Headless UI components for complex, accessible UI elements like Modals, Menus, and Listboxes. These components integrate seamlessly with Tailwind CSS for styling."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);