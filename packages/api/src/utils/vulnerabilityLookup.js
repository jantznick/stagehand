import { VULNERABILITY_APIS, API_ERROR_MESSAGES, ID_PATTERNS } from '../config/vulnerability-apis.js';

class RateLimiter {
  constructor(limit, window) {
    this.limit = limit;
    this.window = window;
    this.tokens = [];
  }

  async waitForToken() {
    const now = Date.now();
    this.tokens = this.tokens.filter(token => now - token < this.window);
    
    if (this.tokens.length >= this.limit) {
      const oldestToken = this.tokens[0];
      const waitTime = this.window - (now - oldestToken);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
    
    this.tokens.push(now);
  }
}

// Rate limiter instance for NVD API
const nvdRateLimiter = new RateLimiter(
  VULNERABILITY_APIS.NVD.rateLimit.requests,
  VULNERABILITY_APIS.NVD.rateLimit.window
);

/**
 * Standardize vulnerability data format across different sources
 */
function standardizeVulnerabilityData(data, source) {
  switch (source) {
    case 'NVD':
      return {
        id: data.cve.id,
        vulnerabilityId: data.cve.id,
        title: data.cve.descriptions?.[0]?.value || 'No title available',
        description: data.cve.descriptions?.find(d => d.lang === 'en')?.value || 'No description available',
        severity: calculateSeverity(data.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore),
        cvssScore: data.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || null,
        remediation: data.cve.configurations?.[0]?.description || null,
        references: {
          urls: data.cve.references?.map(ref => ref.url) || []
        },
        source: 'NVD'
      };

    case 'MITRE':
      return {
        id: data.id,
        vulnerabilityId: data.id,
        title: data.title || 'No title available',
        description: data.description || 'No description available',
        severity: data.severity || 'UNKNOWN',
        cvssScore: null,
        remediation: null,
        references: {
          urls: data.references || []
        },
        source: 'MITRE'
      };

    default:
      throw new Error('Unknown vulnerability data source');
  }
}

/**
 * Calculate severity level based on CVSS score
 */
function calculateSeverity(cvssScore) {
  if (!cvssScore) return 'UNKNOWN';
  if (cvssScore >= 9.0) return 'CRITICAL';
  if (cvssScore >= 7.0) return 'HIGH';
  if (cvssScore >= 4.0) return 'MEDIUM';
  return 'LOW';
}

/**
 * Validate CVE or GHSA ID format
 */
export function validateVulnerabilityId(id) {
  return ID_PATTERNS.CVE.test(id) || ID_PATTERNS.GHSA.test(id);
}

/**
 * Fetch vulnerability data from NVD
 */
async function fetchFromNVD(cveId) {
  await nvdRateLimiter.waitForToken();

  const response = await fetch(
    `${VULNERABILITY_APIS.NVD.baseUrl}?cveId=${cveId}`,
    {
      headers: {
        'Accept': 'application/json'
      },
      timeout: VULNERABILITY_APIS.NVD.timeout
    }
  );

  if (!response.ok) {
    if (response.status === 429) {
      throw new Error(API_ERROR_MESSAGES.RATE_LIMIT_EXCEEDED);
    }
    throw new Error(API_ERROR_MESSAGES.EXTERNAL_API_ERROR);
  }

  const data = await response.json();
  if (!data.vulnerabilities?.[0]) {
    throw new Error('Vulnerability not found in NVD');
  }

  return standardizeVulnerabilityData(data.vulnerabilities[0], 'NVD');
}

/**
 * Fetch vulnerability data from MITRE (fallback)
 */
async function fetchFromMITRE(cveId) {
  const response = await fetch(
    `${VULNERABILITY_APIS.MITRE.baseUrl}${VULNERABILITY_APIS.MITRE.endpoints.lookup}${cveId}`,
    {
      timeout: VULNERABILITY_APIS.MITRE.timeout
    }
  );

  if (!response.ok) {
    throw new Error(API_ERROR_MESSAGES.EXTERNAL_API_ERROR);
  }

  // Note: MITRE's response would need parsing as it's HTML
  // This is a simplified example - in production, implement HTML parsing
  const data = {
    id: cveId,
    title: `${cveId} from MITRE`,
    description: 'Description from MITRE database',
    references: []
  };

  return standardizeVulnerabilityData(data, 'MITRE');
}

/**
 * Lookup vulnerability by ID with fallback mechanism
 */
export async function lookupVulnerability(id) {
  if (!validateVulnerabilityId(id)) {
    throw new Error(API_ERROR_MESSAGES.INVALID_CVE_FORMAT);
  }

  try {
    // Try NVD first
    return await fetchFromNVD(id);
  } catch (error) {
    if (error.message === API_ERROR_MESSAGES.RATE_LIMIT_EXCEEDED) {
      throw error;
    }
    
    try {
      // Fallback to MITRE if NVD fails
      return await fetchFromMITRE(id);
    } catch (mitreError) {
      throw new Error(API_ERROR_MESSAGES.SERVICE_UNAVAILABLE);
    }
  }
}

/**
 * Search for vulnerabilities by keyword (for future implementation)
 */
export async function searchVulnerabilities(query) {
  await nvdRateLimiter.waitForToken();

  const response = await fetch(
    `${VULNERABILITY_APIS.NVD.baseUrl}?keywordSearch=${encodeURIComponent(query)}`,
    {
      headers: {
        'Accept': 'application/json'
      },
      timeout: VULNERABILITY_APIS.NVD.timeout
    }
  );

  if (!response.ok) {
    if (response.status === 429) {
      throw new Error(API_ERROR_MESSAGES.RATE_LIMIT_EXCEEDED);
    }
    throw new Error(API_ERROR_MESSAGES.EXTERNAL_API_ERROR);
  }

  const data = await response.json();
  return data.vulnerabilities?.map(vuln => standardizeVulnerabilityData(vuln, 'NVD')) || [];
}