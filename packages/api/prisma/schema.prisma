datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
//  url      = "postgresql://admin:password@localhost:5432/stagehand?schema=public"
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x"]
}

// Hierarchical Role Definition
enum Role {
  ADMIN
  EDITOR
  READER
}

enum VerificationStatus {
  PENDING
  VERIFIED
}

enum DeploymentStatus {
  PLANNING
  IN_DEVELOPMENT
  TESTING
  RELEASED
  MAINTENANCE
  DISCONTINUED
}

enum TechnologyType {
  LANGUAGE
  FRAMEWORK
  LIBRARY
  TOOL
  PLATFORM
  SERVICE
}

enum ProjectType {
  SERVICE
  LIBRARY
  FRONTEND_APP
  BACKEND_APP
  MOBILE_APP
  OWNED_HARDWARE
  CLOUD_HARDWARE
  EXTERNAL_BOUGHT_SOFTWARE
  CLI_TOOL
  OTHER
}

enum DataClassification {
  PUBLIC
  INTERNAL
  SENSITIVE
  RESTRICTED
}

enum ApplicationCriticality {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum SCMProvider {
  GITHUB
  BITBUCKET
  AZURE_DEVOPS
}

model User {
  id        String    @id @default(cuid())
  email     String    @unique
  password  String? // Hashed password, optional for invited users
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  emailVerified              Boolean   @default(false)
  verificationToken          String?
  verificationTokenExpiresAt DateTime?

  memberships Membership[]
  invitation  Invitation?
  passwordResetToken PasswordResetToken?
  loginTokens LoginToken[]
  
  contacts    Contact[]
  scmIntegrations SCMIntegration[]
}

model Session {
  id        String   @id @default(cuid())
  sid       String   @unique
  data      String
  expiresAt DateTime
}

model Organization {
  id               String    @id @default(cuid())
  name             String
  description      String?
  accountType      String    @default("STANDARD") // STANDARD or ENTERPRISE
  hierarchyDisplayNames Json?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  defaultCompanyId String?

  companies   Company[]
  memberships Membership[]
  autoJoinDomains  AutoJoinDomain[]
  oidcConfiguration OIDCConfiguration?
  integrations      SCMIntegration[]
}

model Company {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  teams      Team[]
  memberships Membership[]
  autoJoinDomains AutoJoinDomain[]
  integrations SCMIntegration[]
}

model Team {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  projects   Project[]
  memberships Membership[]
  integrations SCMIntegration[]
}

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  teamId String
  team   Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  
  memberships Membership[]

  // --- Stagehand Fields ---
  /// Primary URL for the deployed application
  applicationUrl      String?
  /// Current public version, e.g., 2.1.4
  version             String?
  deploymentStatus    DeploymentStatus @default(IN_DEVELOPMENT)
  
  /// Link to the source code repository (e.g., GitHub)
  repositoryUrl       String?
  /// Link to the CI/CD pipeline (e.g., Jenkins, GitHub Actions)
  ciCdPipelineUrl     String?

  /// Timestamp of the last successful scan by any integrated tool
  lastScanDate        DateTime?

  projectType          ProjectType?
  dataClassification   DataClassification?
  applicationCriticality ApplicationCriticality?
  isExternallyExposed  Boolean?          @default(false)

  communicationChannel String?     // e.g., Slack channel link
  documentationUrl     String?     // Link to general project documentation (e.g., Confluence)
  apiReferenceUrl      String?     // Link to API documentation (e.g., Swagger, OpenAPI)
  runbookUrl           String?     // Link to operational runbooks for on-call
  threatModelUrl       String?     // Link to threat model document
  lastSecurityReview   DateTime?   // Date of last manual security review

  /// Points of contact for this application
  contacts    ProjectContact[]
  technologies        ProjectTechnology[]
  dependencies        ProjectDependency[]

  outboundDependencies ProjectRelationship[] @relation("outboundDependencies")
  inboundDependencies  ProjectRelationship[] @relation("inboundDependencies")
  integrations         SCMIntegration[] @relation("DirectProjectIntegrations")

  scmIntegrationId String?
  scmIntegration   SCMIntegration? @relation("ProjectRepositoryLink", fields: [scmIntegrationId], references: [id], onDelete: SetNull)

  findings Finding[]
}

model ProjectRelationship {
  id          String @id @default(cuid())
  description String?
  // Type of relationship, e.g., 'API', 'DATABASE', 'MESSAGE_QUEUE', 'DIRECT_DEPENDENCY'
  type        String

  // The project that has the dependency (the source of the connection)
  sourceProjectId String
  sourceProject   Project @relation("outboundDependencies", fields: [sourceProjectId], references: [id], onDelete: Cascade)

  // The project that is the dependency (the target of the connection)
  targetProjectId String
  targetProject   Project @relation("inboundDependencies", fields: [targetProjectId], references: [id], onDelete: Cascade)

  // A relationship of a certain type between two projects must be unique
  @@unique([sourceProjectId, targetProjectId, type])
}

model Invitation {
  id        String   @id @default(cuid())
  email     String   @unique
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())
  
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  usedAt    DateTime?
  updatedAt DateTime @updatedAt
}

model Membership {
  id        String   @id @default(cuid())
  role      Role
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  companyId String?
  company   Company? @relation(fields: [companyId], references: [id], onDelete: Cascade)

  teamId String?
  team   Team? @relation(fields: [teamId], references: [id], onDelete: Cascade)
  
  projectId String?
  project   Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, organizationId])
  @@unique([userId, companyId])
  @@unique([userId, teamId])
  @@unique([userId, projectId])
}

model Contact {
  id    String  @id @default(cuid())
  name  String
  email String  @unique
  /// e.g., Engineering Manager, External Consultant
  role  String?
  
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  applications ProjectContact[]
}

model ProjectContact {
  projectId String
  project   Project @relation(fields: [projectId], references: [id])
  
  contactId     String
  contact       Contact @relation(fields: [contactId], references: [id])

  /// e.g., 'Primary Owner', 'Technical Lead', 'Product Manager'
  contactType   String

  @@id([projectId, contactId, contactType])
}

model Technology {
  id   String @id @default(cuid())
  name String // e.g., "React", "Snyk", "Jira", "Python"
  type TechnologyType // To categorize the technology
  
  applications ProjectTechnology[]
  dependencies ProjectDependency[]

  @@unique([name, type])
}

model ProjectTechnology {
  id            String @id @default(cuid())
  projectId     String
  project       Project @relation(fields: [projectId], references: [id])

  technologyId  String
  technology    Technology @relation(fields: [technologyId], references: [id])

  /// e.g., 18.2.0 for React
  version       String?
  /// How was this discovered? e.g., 'user-entered' or 'Discovered by Snyk'
  source        String

  @@unique([projectId, technologyId, version])
}

model ProjectDependency {
  id        String  @id @default(cuid())
  name      String  // e.g., "express"
  version   String  // e.g., "4.17.1"
  type      String  // e.g., "npm", "maven"
  
  projectId String
  project   Project @relation(fields: [projectId], references: [id])

  technologyId String?
  technology   Technology? @relation(fields: [technologyId], references: [id])

  @@unique([projectId, name, version])
  @@index([name]) // Index for fast lookups by dependency name
  @@index([name, version]) // Index for fast lookups by name and version
}

model AutoJoinDomain {
  id        String @id @default(cuid())
  domain    String
  role      Role
  status           VerificationStatus @default(PENDING)
  verificationCode String             @unique

  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  
  companyId String?
  company   Company? @relation(fields: [companyId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([domain, organizationId])
  @@unique([domain, companyId])
}

model OIDCConfiguration {
  id               String   @id @default(cuid())
  organizationId   String   @unique
  isEnabled        Boolean  @default(false)
  issuer           String   @unique
  clientId         String
  clientSecret     String
  authorizationUrl String
  tokenUrl         String
  userInfoUrl      String
  defaultRole      Role     @default(READER)
  buttonText       String?

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  selector  String   @unique
  token     String
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model LoginToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
  usedAt    DateTime?
}

model SCMIntegration {
  id        String  @id @default(cuid())
  provider  SCMProvider
  displayName String?

  installationId        String?
  encryptedAccessToken  String
  encryptedRefreshToken String?

  createdById String
  createdBy   User   @relation(fields: [createdById], references: [id], onDelete: Cascade)

  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  companyId String?
  company   Company?      @relation(fields: [companyId], references: [id], onDelete: Cascade)

  teamId String?
  team   Team?         @relation(fields: [teamId], references: [id], onDelete: Cascade)
  
  projectId String?
  project   Project?      @relation("DirectProjectIntegrations", fields: [projectId], references: [id], onDelete: Cascade)

  projectLinks Project[] @relation("ProjectRepositoryLink")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum VulnerabilitySource {
  GITHUB
  SNYK
  QUALYS
  INTERNAL
  MANUAL
}

enum FindingStatus {
  NEW
  TRIAGED
  IN_PROGRESS
  RESOLVED
  IGNORED
}

model Vulnerability {
  id              String    @id @default(cuid())
  // Canonical ID from the source, e.g., 'CVE-2023-1234' or 'GHSA-...'
  vulnerabilityId String
  source          VulnerabilitySource

  title           String
  description     String    @db.Text
  severity        String    // e.g., 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW'
  cvssScore       Float?
  remediation     String?   @db.Text
  references      Json?     // List of URLs to advisories

  findings Finding[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([vulnerabilityId, source])
}

model Finding {
  id              String        @id @default(cuid())
  status          FindingStatus @default(NEW)
  
  projectId       String
  project         Project       @relation(fields: [projectId], references: [id], onDelete:Cascade)

  vulnerabilityId String
  source          VulnerabilitySource // To satisfy the compound key of Vulnerability
  vulnerability   Vulnerability @relation(fields: [vulnerabilityId, source], references: [vulnerabilityId, source])

  // Source-specific details, e.g., { "dependencyName": "lodash", "filePath": "package-lock.json" }
  metadata        Json?

  firstSeenAt DateTime  @default(now())
  lastSeenAt  DateTime  @updatedAt
  resolvedAt  DateTime?

  @@unique([projectId, vulnerabilityId, source])
  @@index([projectId])
} 