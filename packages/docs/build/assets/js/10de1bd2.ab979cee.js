"use strict";(self.webpackChunk_stagehand_docs=self.webpackChunk_stagehand_docs||[]).push([[486],{1184:(e,n,o)=>{o.d(n,{R:()=>c,x:()=>d});var t=o(6540);const s={},r=t.createContext(s);function c(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(r.Provider,{value:n},e.children)}},6493:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>i,contentTitle:()=>d,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"frontend/hooks","title":"Frontend Documentation: Custom Hooks","description":"This document provides a breakdown of the custom React hooks used throughout the application.","source":"@site/docs/frontend/hooks.md","sourceDirName":"frontend","slug":"/frontend/hooks","permalink":"/frontend/hooks","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/stagehand/tree/main/packages/docs/docs/frontend/hooks.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Frontend Documentation: Lib Utilities","permalink":"/frontend/lib"},"next":{"title":"Frontend Documentation: Pages","permalink":"/frontend/pages"}}');var s=o(4848),r=o(1184);const c={},d="Frontend Documentation: Custom Hooks",i={},a=[{value:"Overview",id:"overview",level:2},{value:"<code>useDebounce</code>",id:"usedebounce",level:2},{value:"Usage",id:"usage",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Returns",id:"returns",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"frontend-documentation-custom-hooks",children:"Frontend Documentation: Custom Hooks"})}),"\n",(0,s.jsx)(n.p,{children:"This document provides a breakdown of the custom React hooks used throughout the application."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Custom hooks are reusable functions that encapsulate component logic. They allow us to share stateful logic between different components without repeating code."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"usedebounce",children:(0,s.jsx)(n.code,{children:"useDebounce"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"File:"})," ",(0,s.jsx)(n.code,{children:"packages/web/src/hooks/useDebounce.js"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," To debounce a rapidly changing value. This is primarily used to delay an action (like an API call) until the user has stopped typing for a specified period."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import { useDebounce } from '../hooks/useDebounce';\n\nfunction SearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  \n  // The debouncedSearchTerm will only update 500ms after the user stops typing\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\n\n  useEffect(() => {\n    // This effect will run only when debouncedSearchTerm changes\n    if (debouncedSearchTerm) {\n      // Perform the API call with the debounced term\n      searchApi(debouncedSearchTerm);\n    }\n  }, [debouncedSearchTerm]);\n\n  return (\n    <input \n      type=\"text\"\n      value={searchTerm}\n      onChange={(e) => setSearchTerm(e.target.value)}\n    />\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"value"})," (any): The value to be debounced (e.g., the ",(0,s.jsx)(n.code,{children:"searchTerm"})," from state)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"delay"})," (number): The debounce delay in milliseconds."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"returns",children:"Returns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"(any)"}),": The debounced value, which will be updated only after the specified ",(0,s.jsx)(n.code,{children:"delay"})," has passed without the input ",(0,s.jsx)(n.code,{children:"value"})," changing."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);